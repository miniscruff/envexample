package main

/* todo list
env tag:
name defined
name not defined

required
not empty
unset
from file
Prefix for nested

tags:
env expand
env separator ( for slices )
env default

options:
tag name
use field name by default
required if no def
*/

import (
	"flag"
	"fmt"
	"go/ast"
	godoc "go/doc"
	"go/parser"
	"go/token"
	"io"
	"log"
	"os"
	"reflect"
	"sort"
	"strings"
)

// goreleaser injected values
var version = "dev"

var header = `# Code generated. DO NOT EDIT.
# Generated by envexample %s.
`

type PackageTypes map[string]*godoc.Type

type StructInfo struct {
	Name   string
	Doc    string
	Prefix string
	Fields []FieldInfo
}

type FieldInfo struct {
	Name     string
	Doc      string
	TypeName string
}

func (s *StructInfo) Write(w io.Writer) error {
	w.Write([]byte("test"))
	return nil
}

func buildField(fset *token.FileSet, field *ast.Field, queue *[]string) FieldInfo {
	props := FieldInfo{
		Name: field.Names[0].Name,
		Doc:  field.Doc.Text(),
	}

	if field.Tag == nil {
		return props
	}

	switch fieldType := field.Type.(type) {
	case *ast.Ident:
		props.TypeName = fieldType.Name
	case *ast.ArrayType:
		rootType := fieldType.Elt.(*ast.Ident)
		props.TypeName = rootType.Name
		// props.Slice = true
	case *ast.StarExpr:
		rootType := fieldType.X.(*ast.Ident)
		*queue = append(*queue, rootType.Name)
		props.TypeName = rootType.Name
	case *ast.SelectorExpr:
		rootType := fieldType.Sel
		*queue = append(*queue, rootType.Name)
		props.TypeName = rootType.Name
	default:
		panic(fmt.Errorf("unknown field type: %T for field: '%v'", fieldType, field.Names[0]))
	}

	tags := reflect.StructTag(strings.Trim(field.Tag.Value, "`"))

	if _, ok := tags.Lookup("env"); ok {
	}

	if _, ok := tags.Lookup("envPrefix"); ok {
		*queue = append(*queue, props.TypeName)
	}

	return props
}

func buildStruct(fset *token.FileSet, docType *godoc.Type, queue *[]string) StructInfo {
	typeProps := StructInfo{
		Name: docType.Name,
		Doc:  docType.Doc,
	}

	fieldProps := make([]FieldInfo, 0)

	for _, spec := range docType.Decl.Specs {
		typeSpec, _ := spec.(*ast.TypeSpec)
		structType, ok := typeSpec.Type.(*ast.StructType)

		if !ok {
			continue
		}

		for _, field := range structType.Fields.List {
			newField := buildField(fset, field, queue)
			fieldProps = append(fieldProps, newField)
		}
	}

	sort.Slice(
		fieldProps,
		func(i, j int) bool {
			return fieldProps[i].Name < fieldProps[j].Name
		},
	)

	typeProps.Fields = fieldProps

	return typeProps
}

func buildUniqueTypes(
	fset *token.FileSet,
	packageTypes PackageTypes,
	packageName ...string,
) []StructInfo {
	typeQueue := packageName
	completed := make(map[string]struct{}, 0)
	allTypeProps := make([]StructInfo, 0)

	for {
		if len(typeQueue) == 0 {
			break
		}

		typeName := typeQueue[0]
		typeQueue = typeQueue[1:]

		docType, found := packageTypes[typeName]
		if !found {
			continue
		}

		// don't write objects more than once
		_, seen := completed[typeName]
		if seen {
			continue
		}

		completed[typeName] = struct{}{}

		typeProps := buildStruct(fset, docType, &typeQueue)
		allTypeProps = append(allTypeProps, typeProps)
	}

	return allTypeProps
}

func getProjectPackages(packageName string) (*token.FileSet, PackageTypes) {
	fset := token.NewFileSet()
	packages, _ := parser.ParseDir(fset, "./"+packageName, nil, parser.ParseComments)

	projectPackage := packages[packageName]
	p := godoc.New(projectPackage, "./", 0)

	projectPackages := make(PackageTypes)
	for _, t := range p.Types {
		projectPackages[t.Name] = t
	}

	return fset, projectPackages
}

func main() {
	var (
		exportFile   string
		configStruct string
		dryRun       bool
		showVersion  bool
		showHelp     bool
	)

	flag.StringVar(&exportFile, "export", ".env.example", "`filepath` to export generated example to")
	flag.StringVar(&configStruct, "struct", "", "`struct` to build example from")
	flag.BoolVar(&dryRun, "dry", false, "output to stdout instead of writing to file")
	flag.BoolVar(&showVersion, "v", false, "show version")
	flag.BoolVar(&showHelp, "h", false, "show help")

	flag.Parse()

	if showVersion {
		fmt.Println("v" + version)
		os.Exit(0)
	}

	if showHelp {
		flag.PrintDefaults()
		os.Exit(0)
	}

	if configStruct == "" {
		flag.PrintDefaults()
		log.Fatal("config struct not defined")
	}

	if !dryRun && exportFile == "" {
		flag.PrintDefaults()
		log.Fatal("export file empty and not using dry run")
	}

	var writer io.Writer
	if dryRun {
		writer = os.Stdout
	} else {
		file, err := os.Create(exportFile)
		if err != nil {
			log.Fatal("error creating file", err)
		}
		defer file.Close()
		writer = file
	}

	fset, projPkgs := getProjectPackages(".")
	// uniqTypes := buildUniqueTypes(fset, projPkgs, configStruct)

	writer.Write([]byte(fmt.Sprintf(header, "v"+version)))
	for _, info := range uniqTypes {
		err := info.Write(writer)
		if err != nil {
			log.Fatal("error writing struct", err)
		}
	}
}
