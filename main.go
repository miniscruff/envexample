package main

/* todo list
env tag:
no env tag at all ``
name defined `env:"NAME"`
name not defined `env:""`
required `env:"NAME,required"`
not empty `env:"NAME,notempty"`
unset `env:"NAME,unset"`
from file `env:"NAME,fromfile"`


tags:
env prefix `envPrefix:"DB_"`
env expand `envExpand:"true"`
env separator ( for slices ) `envSeperator:":"`
env default `envDefault:"DEFAULT_VALUE"`

options:
tag name
use field name by default
required if no def
*/

import (
	"errors"
	"flag"
	"fmt"
	"go/ast"
	godoc "go/doc"
	"go/parser"
	"go/token"
	"io"
	"log"
	"os"
	"reflect"
	"sort"
	"strings"
)

const (
	header = "# Generated by envexample %s.\n\n"
)

var (
	version = "dev" // injected by goreleaser

	// errors
	errUnableToWriteField = errors.New("unable to write field")
	errUnableToWrite      = errors.New("unable to write")
)

type PackageTypes map[string]*godoc.Type

func WriteField(writer io.Writer, field *ast.Field, prefix string) error {
	// just checking the first write
	if _, err := writer.Write([]byte("# ")); err != nil {
		return fmt.Errorf("%w: %w", errUnableToWrite, err)
	}

	_, _ = writer.Write([]byte(strings.Replace(strings.Trim(field.Doc.Text(), "\n"), "\n", "\n# ", -1)))
	_, _ = writer.Write([]byte("\n"))

	tags := reflect.StructTag(strings.Trim(field.Tag.Value, "`"))

	if envName, ok := tags.Lookup("env"); ok {
		_, _ = writer.Write([]byte(prefix + envName))
	} // will need to find what the name is without the env struct tag

	_, _ = writer.Write([]byte("="))
	if def, ok := tags.Lookup("envDefault"); ok {
		_, _ = writer.Write([]byte(def))
	} // need to write something else as the value

	switch fieldType := field.Type.(type) {
	case *ast.Ident:
		// props.TypeName = fieldType.Name
	case *ast.ArrayType:
		// rootType := fieldType.Elt.(*ast.Ident)
		// props.TypeName = rootType.Name
		// props.Slice = true
	case *ast.StarExpr:
		// rootType := fieldType.X.(*ast.Ident)
		// props.TypeName = rootType.Name
	case *ast.SelectorExpr:
		// rootType := fieldType.Sel
		// props.TypeName = rootType.Name
	default:
		return fmt.Errorf(
			"unknown field type: %T for field '%v': %w",
			fieldType,
			field.Names[0],
			errUnableToWriteField,
		)
	}

	// if envPrefix, ok := tags.Lookup("envPrefix"); ok {
	// *queue = append(*queue, QueueEntry{
	// TypeName: props.Name,
	// Prefix:   prefix + envPrefix,
	// })
	// }

	_, _ = writer.Write([]byte("\n"))

	return nil
}

func WriteStruct(writer io.Writer, docType *godoc.Type, prefix string) error {
	// just checking the first write
	if _, err := writer.Write([]byte("# ")); err != nil {
		return fmt.Errorf("%w: %w", errUnableToWrite, err)
	}

	_, _ = writer.Write([]byte(strings.Replace(strings.Trim(docType.Doc, "\n"), "\n", "\n# ", -1)))
	_, _ = writer.Write([]byte("\n#\n"))

	fields := make([]*ast.Field, 0)

	specs := docType.Decl.Specs
	for _, spec := range specs {
		typeSpec, _ := spec.(*ast.TypeSpec)

		structType, ok := typeSpec.Type.(*ast.StructType)
		if !ok {
			continue
		}

		fields = append(fields, structType.Fields.List...)
	}

	sort.SliceStable(fields, func(i, j int) bool {
		return fields[i].Names[0].Name < fields[j].Names[0].Name
	})

	for _, field := range fields {
		if err := WriteField(writer, field, prefix); err != nil {
			return fmt.Errorf("%w '%v': %w", errUnableToWriteField, field.Names[0].Name, err)
		}
	}

	return nil
}

func NewPackageTypes(packageName string) PackageTypes {
	fset := token.NewFileSet()
	packages, _ := parser.ParseDir(fset, "./", nil, parser.ParseComments)

	projectPackage := packages[packageName]
	p := godoc.New(projectPackage, "./", 0)

	projectPackages := make(PackageTypes)
	for _, t := range p.Types {
		projectPackages[t.Name] = t
	}

	return projectPackages
}

func main() {
	var (
		exportFile   string
		configStruct string
		packageName  string
		dryRun       bool
		showVersion  bool
		showHelp     bool
	)

	flag.StringVar(&exportFile, "export", ".env.example", "`filepath` to export generated example to")
	flag.StringVar(&configStruct, "struct", "", "`struct` to build example from")
	flag.StringVar(&packageName, "package", "main", "`package` our config struct is located in")
	flag.BoolVar(&dryRun, "dry", false, "output to stdout instead of writing to file")
	flag.BoolVar(&showVersion, "v", false, "show version")
	flag.BoolVar(&showHelp, "h", false, "show help")

	flag.Parse()

	if showVersion {
		fmt.Println("v" + version)
		os.Exit(0)
	}

	if showHelp {
		flag.PrintDefaults()
		os.Exit(0)
	}

	if configStruct == "" {
		flag.PrintDefaults()
		log.Fatal("config struct not defined")
	}

	if !dryRun && exportFile == "" {
		flag.PrintDefaults()
		log.Fatal("export file empty and not using dry run")
	}

	var writer io.Writer
	if dryRun {
		writer = os.Stdout
	} else {
		file, err := os.Create(exportFile)
		if err != nil {
			log.Fatal("error creating file", err)
		}
		defer file.Close()
		writer = file
	}

	pkgTypes := NewPackageTypes(packageName)

	_, err := writer.Write([]byte(fmt.Sprintf(header, version)))
	if err != nil {
		log.Fatal(fmt.Errorf("%w: %w", errUnableToWrite, err))
	}

	err = WriteStruct(writer, pkgTypes[configStruct], "")
	if err != nil {
		log.Fatal("error writing struct", err)
	}
}
